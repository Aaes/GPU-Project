%!TEX root = /Users/Nikolaj/Developer/GPU-Project/Report/Report.tex
%Husk at nævne at Middle stepsize er hardcoded til 2.
%Husk at skrive noget om first step der i princippet ikke er en del af matematikken \\
%Husk at nævne at vi i Middle har sat k3 = k2;
%Husk at nævne at det antal steps vi tager kan variere i forhold til matematikken fordi vi tager et "Helt" step hver gang vi laver et firstStep hvor det jo i virkeligheden er en brøkdel af et step. Det gør ikke noget for resultatet, men hvis man tæller steps i programmet vil det ikke give det rigtige antal.
%	I den kode der er nu er insurance holder kvinde og spouse mand ALTID

After we established the mathematical base we implemented a C solution. Instead of implementing the solution directly into CUDA C we chose to implement a C solution first to eliminate any bugs that were purely C specific. This also made it easier to debug since CUDA C program are generally harder to debug (INDSÆT REF?). The implementation is based on the provided C\# code and to conform to that, the middle model's stepsize is set to 2 by default and the insurance holder is always a woman and the spouse is always a man.\\

The first step was to implement the utility methods used for calculating trivial equations and were mostly taken directly from the original C\# implementation. The methods in question are \texttt{gTau(double tau)}, \texttt{f(double eta, double tau)}, \texttt{k(double tau, double r, double g)}, \texttt{r\_(double t)}, \texttt{GmFemale(double t)} and \texttt{GmMale(double t)}. These are all used to calculate components in each of the different differential equations. \\

The second step was to create the program's entry point, the main method. This would be responsible for initializing the $g$, $r$ and $x$ variable as well as the stepsizes for each model. \\

The next step was to split implement the base for the three models. Each model has a main method (\texttt{Outer(..)}, \texttt{Middle(..)} and \texttt{Inner(..)}), a method used for the Runge Kutta method (\texttt{OuterRK(..)}, \texttt{MiddleRK(..)} and \texttt{InnerRK(..)}) and a method that only contains the differential equation for the models (\texttt{OuterDiff(..)}, \texttt{MiddleDiff(..)} and \texttt{InnerDiff(..)}). While creating a Runge Kutta method for each model seems excessive because it serves a the same function in each model it was necessary later on because CUDA C does not support function pointers on compute capabilities lower than 2.0. If the implementation was only meant for the C programming language a single Runge Kutta method that took a function pointer would have been sufficient. \\

Each of the models' main methods are responsible for executing the corresponding Runge Kutta method the correct number of times. This is done by calculating exactly how many full steps it needs to perform by using the \texttt{floor(double x)} method. When using this method we get an integer representation of how many steps we need to take in that particular model but since we are flooring the amount of steps there might be a step remainder smaller than 1, that we need to consider. To take this into account we use what we refer to as the first step. Before each model starts to perform the full number of steps it calculates the remainder of the flooring and takes a step to counter it. 

This is not necessary for the middle model since the middle model's amount of steps is $119 \times stepsize$ which means that there will never be a remainder if the stepsize is a integer. It also means that the amount of full steps the middle model takes is constant and is therefore calculated in the programs main method. \\

As an additional optimization we found that the equations for calculating $k2$ and $k3$ in \texttt{MiddleRK(..)} are identical and chose to just calculate this value once and the use it both places. 
